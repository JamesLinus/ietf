<?xml version="1.0" encoding="US-ASCII"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd">
<?xml-stylesheet type="text/xsl" href="rfc2629.xslt" ?>
<?rfc toc="no" ?>
<?rfc symrefs="yes" ?>
<?rfc iprnotified="yes" ?>
<?rfc strict="yes" ?>
<?rfc compact="yes" ?>
<?rfc sortrefs="yes" ?>
<?rfc colonspace="yes" ?>
<?rfc rfcedstyle="no" ?>
<?rfc tocdepth="4"?>
<rfc category="exp"
     docName="draft-jennings-core-transitive-trust-enrollment-00"
     ipr="trust200902">
  <front>
    <title abbrev="Transitive Trust Enrollment">Transitive Trust Enrollment
    for Constrained Devices</title>

    <author fullname="Cullen Jennings" initials="C." surname="Jennings">
      <organization>Cisco</organization>

      <address>
        <postal>
          <street>170 West Tasman Drive</street>

          <city>San Jose</city>

          <region>CA</region>

          <code>95134</code>

          <country>USA</country>
        </postal>

        <phone>+1 408 421-9990</phone>

        <email>fluffy@cisco.com</email>
      </address>
    </author>

    <date day="17" month="February" year="2012" />

    <area>APP</area>

    <abstract>
      <t>This specification defines a system that allows constrained internet
      devices to securely enroll into a system. It is based on the idea that
      each device will be manufactured with a one time password that can be
      used by the customer to tell the device which controller to enroll
      with.</t>
      <t>
        This is an very early sketch of solution and still lacking many details.
      </t>
    </abstract>
  </front>

  <middle>
    <section title="Introduction">
      <t>Secure enrollment of devices into internet based systems has never
      been easy. The constrained devices that need to be enrolled into systems
      today face many challenges. Often they have no user interface such as a
      keyboard or screen - they might have only a single button or LED. At the
      time they are installed, there may not be a working network or power.
      These devices are being used for increasingly more important and safety
      critical applications. This documents specifies an enrollment system for
      such devices.</t>

      <t>The simplified high level information flow is illustrated in the
      following figure. The goal is get to the point where there Device knows
      that it should be talking to the Controller.</t>

      <figure>
        <artwork alt="Go Read the TXT version of this draft"
                 src="tte-boxes-simple.png"><![CDATA[TODO ASCII FIGURE 
]]></artwork>
      </figure>

   <t>When the Manufacture builds the Device, they include an One Time Password
   (OTP) that the Introduce can use to enroll the Device with the
   Controller. The manufacture also runs a web site know as the MotherShip that
   knows the OTP for every device that Manufactures builds. The device can
   include the OTP as a QR code on the outside of the device. When the device is
   installed, the installer uses a software agent known as the Introducer. The
   Introducer would typically be something like an application running on an
   iPhone. When the device is installed, the Introducer can scan the QR code the
   device to find the OTP (Message 1). The Introducer then contacts the
   MotherShip and uses the OTP to tell the MotherShip which Controller this
   Device is should use (Message 3). Later, the first time the Device boots up
   and gets network connectivity, it contacts the MotherShip and MotherShip
   tells the device which Controller to talk to (Message 3). From that point on,
   any time the device boots, it can directly communicate with the Controller
   (Message 4). The actual message flow is slightly more complicated and shown
   in section TODO but uses the same basic idea as this simplified flow. </t>

      <t>The system is designed to achieve several desirable properties:<list
          style="symbols">
          <t>Can work for Devices with very limited memory and processing
          power</t>

          <t>Does not require network or power to be up when the Device is
          installed</t>

          <t>Is fairly secure (see more in the security section)</t>

          <t>Minimal addition to manufacturing costs</t>

          <t>The installer can detect if the OTP has already been used</t>

          <t>Provides a works flow where a Device does not need to be taken
          out of the box to be enrolled. This can be very important for enable
          consumers to self service enroll devices they buy from a service
          provider.</t>

          <t>Works with common Firewall and NAT network topologies</t>
        </list></t>

        <t>One of the key steps in making this system work is getting the OTP
        from the Device to Introducer. There are several ways that could happen
        but a few of the approaches consider here are:</t>

      <t><list style="symbols">
          <t>Using a QR code or other bar code printed on the Device and/or
          box it comes in.</t>

          <t>Having a single LED on the device that blinks out the OTP
          information and using a video capture application on the Introducer
          to read this.</t>

          <t>The manufacture providing the OTP in some other machine readable
          form</t>

          <t>Including the OTP in an RFID tag on the device that can be read
          by the Introducer.</t>

          <t>Some electrical interface (such as one wire memory) on the Device
          that can be read by the Introducer.</t>
        </list></t>

        <t>The semantic level information in each message is discussed in XXX
        and the syntax of the messages is discussed in XXX. The security
        properties of the system are described in XXX.</t>

    </section>


    <section title="TODO">

       <t>The high level information flow is illustrated in the following
      figure. The goal is get to the point where there Device knows that it
      should be talking to the Controller, and the Controller knows it should
      be talking the Device and the Device and Controller can communicated
      using CoAP and authenticate each other using their public keys.</t>

      <figure>
        <artwork alt="Go Read the TXT version of this draft"
                 src="tte-boxes.png"><![CDATA[TODO ASCII FIGURE 
]]></artwork>
      </figure>

      <t>When the Manufacture builds the Device, they include an One Time
      Password (OTP) that the Introduce can use to enroll the Device with the
      Controller (Message 1). The manufacture also runs a web site know as the
      MotherShip that knows the OTP for every device that Manufactures builds
      (Message 2). The device can include the OTP as a QR code on the outside
      of the device. When the device is installed, the installer uses a
      software agent known as the Introducer. The Introducer would typically
      be something like an application running on an iPhone. When the device
      is installed, the Introducer can scan the QR code the device to find the
      OTP (Message 3). The Introducer then contacts the MotherShip and uses
      the OTP to tell the MotherShip which Controller this Device is should
      use (Message 4 and 5). Later, the first time the Device boots up and
      gets network connectivity, it contacts the MotherShip to find out if it
      has been assigned to a controller (Message 9). The MotherShip tells the
      device which Controller to talk to which the Device saves in non
      volatile memory (Message 10). From that point on, any time the device
      boots, it can directly communicate with the Controller (Message 11).</t>

      <t>The Introducer has the option of informing Controller about any
      Devices that it has enrolled with this Controller (Message 6). The
      controller can optionally contact the MotherShip to find out about the
      status of any Devices that it has not heard from (Messages 7 and 8).</t>

    </section>

    <section title="Enrollment Information Flow ">
      <t>The Manufacture, Device, MotherShip, Introducer, and Controller are
      abbreviated M,D,MS,I,C respectively. The Device, MotherShip, and
      Controller all use CoAP to communicate with each other and thus each
      have a asymmetric key pair that is used to form the DTLS connections
      between them. The MotherShip acts as an HTTP server to communicate with
      the Introducer and Controller and needs a certificates to use HTTPS.</t>

      <t>It is assumed that the Device may have a NAT between it and the
      Controller with the Device on the inside of the NAT. The MotherShip is
      assume to be a generally accessible server on the internet but the
      Controller and Device can be on the inside of a Firewall and/or NAT
      between them and the internet.</t>

      <t>In the following message flow we use the following definitions:<list
          style="hanging">
          <t hangText="Fingerprint">This refers to a hash of the DTLS public
          key used by the associated network element. So "MS Fingerprint"
          means a fingerprint of the public key that the MotherShip will use
          when forming CoAP connections over DTLS.</t>

          <t hangText="MS ID">A 32 bit integer that uniquely identifies the
          MotherShip. Section XXX explains how to use the MS ID to create a
          URL than can be used to contact the MotherShip</t>

          <t hangText="Dev ID">A 32 bit integer that identifies the Device and
          when combined with the MotherShip is unique. Two devices that use
          the same MotherShip can not have the same Dev ID</t>

          <t hangText="Dev URN">A globally unique URN assigned by the
          Manufacture to uniquely identify this device. This SHOULD be one of
          the URNs from TODO REF.</t>

          <t hangText="OTP">The One Time Password created by the manufacture
          for enrollment of the Device. This is an cryptographically random 64
          bit integer. </t>

          <t hangText="C Addr">Address of the Controller. This is an IPv4 or
          IPv6 address and port which the Device can use to form a CoAP
          connection to the Controller.</t>

          <t hangText="Dev Descp">A locally significant string that the
          Introducer can assign to Device. For example, the convention for a
          thermostat in building 30, floor2, office 361 might be assign the
          string "BLD30/2/361 - Thermostat". This string is purely provided as
          a way for the Introducer and Controller to exchange information that
          may be useful for the Installer.</t>

          <t hangText="Dev Status">The Controller can query the MotherShip for
          the enrollment status of a Device that is enrolled with that
          Controller. The various stats returned are discussed in XXX. TODO
          MOVE If the MotherShip does not consider the query a valid device
          due to either an incorrect Device URN or OTP or that the device has
          been revoked, it</t>
        </list></t>

      <figure>
        <artwork alt="Go Read the TXT version of this draft"
                 src="tte-arrows.png"><![CDATA[participant Manufacture
participant Device
participant MotherShip
participant Introducer
participant Controller
 
Manufacture-->Device: 1 MS ID,MS Fingerprint,\nDev ID, OTP
Manufacture-->MotherShip: 2 Dev URN, Dev ID, OTP
note right of Introducer: User tells I:\n C Addr, Dev Desc
Device-->Introducer: 3 MS ID, Dev ID, OTP
Introducer->MotherShip: 4 Dev ID, OTP,\nC Addr, C Fingerprint
MotherShip->Introducer: 5 Dev URN,\nDev Fingerprint
Introducer->Controller: 6 Dev URN,\nDev Fingerprint, \nOTP, Dev Desc
Controller->MotherShip: 7 Dev URN, OTP
MotherShip->Controller: 8 Dev State
Device->MotherShip: 9 Dev URN
MotherShip->Device: 10 Addr,\n C Fingerprint
Device->Controller: 11 Hello
Controller->Device: 12 HelloAck
]]></artwork>
      </figure>

      <t>Message Details</t>

      <t>When the device is build, it needs to be assigned a globally unique
      URN, a Dev ID, and an MotherShip. A single manufacture MAY operate many
      MotherShips as each one only support 16 million devices. A perfectly
      reasonable way to generate the Dev ID is to use the least significant 32
      bits of the Device URN. The device needs to be programmed with the IP
      address and port of the MotherShip along with the fingerprint of the
      public key that the MotherShip will use in the DTLS CoAP exchange.</t>

      <t>TODO ref RFC 5785 well known</t>

      <t>The creation of the MotherShip domain name is discussed in XXX. The
      QR code fore the Device MUST be a HTTPS URL that points at the
      appropriate MotherShip and MUST include a URL parameter called "otp"
      that is set to OTP represented in hexadecimal and MUST include a URL
      parameter called "devid" that is set to the Device ID represented in
      hexadecimal. It MUST use the default HTTP port and MUST have an absolute
      path of /.wellknown/tte. As an example, if the MotherShip domain name
      was ""tte-000000.net", the OTP was 0x123456789abcdef0 and the Device ID was
      0xABCDEF01, a valid URL would be:</t>

      <figure>
        <artwork>
<![CDATA[
https://tte-000000.net/.well-known/tte?
        otp=123456789abcdef0,DevID=abcdef01]]></artwork>
      </figure>

      <t>The QR code SHOULD use an error coding level of "H". This would
      generate the following QR code - TODO- REGENERATE THIS QR</t>

      <figure>
        <artwork alt="Go Read the TXT version of this draft" src="qrcode.png"><![CDATA[QR code in ASCII art left as an exercise 
to the reader but there is one in the PDF version.      ]]></artwork>
      </figure>

      <t>The Introduces reads the QR code with uses the URL found the QR code
      to contact the MotherShip in messages 4 and 5. The URL is referred to as
      the Enrollment URL .</t>

      <t>Message 4 and 5 MUST be sent over TLS and the Introducer MUST verify
      the HTTPS certificate of the MotherShip matches the URL. The Introducer
      can either perform an HTTPS GET or POST. If the introducer does at GET,
      it MUST make an HTTPS GET request to the Enrollment URL and MUST act as
      web browser. IN the case of a GET, the MotherShip MUST return a web
      pages that allows the user to enter the IP address and port of the
      Controller as well as the fingerprint of the Controllers public key used
      in CoAP. If the Controller does not wish to act as a web browser,
      instead of using the GET, it will use a PUT. When using a PUT, the
      Controller MUST make a HTTPS POST request to an URL formed by appending
      three parameters to the Enrollment URL. The parameters are cip which
      MUST have the IP address of the Controller, cport which MUST have the
      port of the Controller, and cfingerprint which MUST have the fingerprint
      of the Controllers Public Key represented in hexadecimal. If, and only
      if, the MotherShip successful stored the address, it MUST return a HTTP
      200 response with a JSON string containing the URN and Fingerprint for
      that Device. The format of this object is described in XXX.</t>

      <t>Once the MotherShip has successfully stored the Controller address
      for a given OTP. It MUST not allow that OTP to be used again to store an
      address for that Device. The OTP can be used after this to query the
      status of the enrollment as described in XXX.</t>

      <t>Message 6 is optional and MAY be omitted. As some point after the
      Introducer has successfully mapped the Device to the Controller, it can
      send a HTTP or HTTPS request to the controller to notify that it can
      expect to hear from a particular device. This does not need happen
      immediately and the information can be saved so it can be done far in
      the future. This might happen in a case where Devices were being
      installed before the Controller was even operational. In other cases it
      might be done immediately. (TODO - look at in web browser case having
      MotherShip redirect Introducer to Controller after successful
      Introduction. This is done with a HTTP POST to TBD URL with parameters
      to convey the Device URN and Fingerprint learned from the MotherShip,
      the OTP password that so the Controller and use it in query the
      MotherShip for status, and a locally significant description string that
      can be used to help label the device for management reasons.</t>

      <t>In the case where the Controller has learned the URN and OTP for a
      given Device, it MAY query the MotherShip to find out the enrollment
      status. It does this with an HTTP GET request to TBD URL. The various
      status that can be returned in TBD JSON doc are: revoked, not mapped,
      mapped, registered. TODO better names and descriptions.</t>

      <t>When the Device boots and has network connectivity, it attempts to
      form a CoAP connection to the MotherShip. It does a CoAP GET request to
      TBD URL passing it's URN as a parameter. Details of this message are
      provided in XXX. The Device MUST check that the Public Key provided by
      the MotherShip in the DTLS connection matches the fingerprint provided
      by the Manufacture. The MotherShip needs to look at the Public Key
      provided in the DTLS and ensure that it matches the fingerprint for this
      Device that provided by the Manufacture. If it does match, the
      MotherShip MUST return (in Message 10) the IP address and port for the
      Controller as wells as the Fingerprint for the controllers public key.
      Details for they syntax of these messages are provided in XXX. If this
      is successful, the Device MUST store the address and fingerprint for the
      Controller in non volatile memory and on future reboots, skip all the
      steps before this and directly connect to the controller.</t>

      <t>At this point, the Device can form a CoAP connection to the
      Controller. The Device can verify that it is speaking to the correct
      Controller by checking the DTLS Public Key matches the fingerprint for
      the controller that was retrieved from the MotherShip. If the Introduce
      contact the controller in message 6, then the Controller has the
      fingerprint of the Device and verify it matches the DTLS Public Key. If
      the Controller does not have the information from Message 6, it can be
      configured to either ignore the Device until it gets the information
      from the Introducer or it MAY be configured to accept the connection
      based purely on the</t>
    </section>

    <section title="Message Formats">
      <t>TODO</t>
    </section>

    <section anchor="sec-sec" title="Security Considerations">
      <t>TBD</t>

      <t>Replacing Dead Controller with new - need the private keys of old
      one.</t>

      <t>What happens in OTP stolen during Device transit</t>

      <t>Network topology consideration - Introducer can install firewall
      rules that allow Device to contact MotherShip.</t>

      <t>why works with NATs / FWs.</t>

      <t></t>
    </section>

    <section title="MotherShip ID and URLs">
      <t>This system requires there is a programmatic way to go from a
      MotherShip ID, which is a 32 bit integer, to a URL that can be used to
      contact that MotherShip. The approach here is to use DNS to that. For
      MotherShip that have a high order byte of 0x00, the DNS host name of the
      MotherShip if formed by prepending "tte-" to the lower order 24 bits of
      the MotherShip ID represented in hexadecimal then appending ".net". So the
      host name for the MotherShip ID 10 would be "tte-00000A.net". Mothership
      ID that have a high order byter other than 0x00 are reserved for future
      specifications. </t>

      <t>A Manufacture gets a MotherShip ID simply be registering the
      corresponding DNS entry. The MotherShip ID zero is reserved for
      examples, and MUST NOT be treated as a valid ID by operational
      systems.</t>
    </section>

    <section title="IANA Considerations">
      <t>TODO - registry for top byte of MotherShip ID</t>

      <t>TODO register .wellknown HTTP URL</t>
    </section>

    <section title="Light Based Enrollment">
      <t>An alternative to QR codes is to have an LED on the device flash out
      the relevant information to the introducer. The output string is formed by
d      concatenating a 16 bit start of message constant value of 0x0001, followed
      by the mothership ID, device ID, OTP, then 8 bit twos compliment checksum
      value of the previous bytes including the start of message constant. All
      values are in network byte order. The resulting string is output using
      zero return encoding on the LED at a baud rate of 15Hz. This allows a
      device such as a smartphone with video capture to detect the signal using
      a typical video camera and recover the information. TODO - see if this
      works at 30Hz. See about encoding multiple intensity levels in the LED -
      initial experiments indicate this does not work as auto contrast tends to
      saturate LED range.  </t>
    </section>

    <section title="Bulk Enrollment">
      <t> Imagine one wants to enroll a whole box of sensors. We should define
      some scheme where one can simply barcode something on outside of box and
      can bulk enroll all the sensors in the box. Perhaps have a scheme where
      there is a master secret and start and end device ID on the outside of box
      barcode. Then the OTP for a given device is generated using the master
      secret and deviceID of that device. Need to sort out details of scheme
      like this.  </t>
    </section>

    <section title="Acknowledgments">
      <t>Some of the fundamental ideas in this draft where inspired by Max
      Pritikin work. I'd like to thank the following people for review
      comments: Eric Rescorla </t>
    </section>
  </middle>

  <back>
    <references title="Normative References">
      <reference anchor="RFC2119">
        <front>
          <title abbrev="RFC Key Words">Key words for use in RFCs to Indicate
          Requirement Levels</title>

          <author fullname="Scott Bradner" initials="S." surname="Bradner">
            <organization>Harvard University</organization>

            <address>
              <postal>
                <street>1350 Mass. Ave.</street>

                <street>Cambridge</street>

                <street>MA 02138</street>
              </postal>

              <phone>- +1 617 495 3864</phone>

              <email>sob@harvard.edu</email>
            </address>
          </author>

          <date month="March" year="1997" />

          <area>General</area>

          <keyword>keyword</keyword>
        </front>

        <seriesInfo name="BCP" value="14" />

        <seriesInfo name="RFC" value="2119" />

        <format octets="4723"
                target="http://www.rfc-editor.org/rfc/rfc2119.txt" type="TXT" />

        <format octets="17491"
                target="http://xml.resource.org/public/rfc/html/rfc2119.html"
                type="HTML" />

        <format octets="5777"
                target="http://xml.resource.org/public/rfc/xml/rfc2119.xml"
                type="XML" />
      </reference>
    </references>

    <references title="Informative References">
      <reference anchor="I-D.ietf-core-coap">
        <front>
          <title>Constrained Application Protocol (CoAP)</title>

          <author fullname="Zach Shelby" initials="Z" surname="Shelby">
            <organization></organization>
          </author>

          <author fullname="Klaus Hartke" initials="K" surname="Hartke">
            <organization></organization>
          </author>

          <author fullname="Carsten Bormann" initials="C" surname="Bormann">
            <organization></organization>
          </author>

          <author fullname="Brian Frank" initials="B" surname="Frank">
            <organization></organization>
          </author>

          <date day="31" month="October" year="2011" />

          <abstract>
            <t>This document specifies the Constrained Application Protocol
            (CoAP), a specialized web transfer protocol for use with
            constrained networks and nodes for machine-to-machine applications
            such as smart energy and building automation. These constrained
            nodes often have 8-bit microcontrollers with small amounts of ROM
            and RAM, while networks such as 6LoWPAN often have high packet
            error rates and a typical throughput of 10s of kbit/s. CoAP
            provides a method/response interaction model between application
            end-points, supports built-in resource discovery, and includes key
            web concepts such as URIs and content-types. CoAP easily
            translates to HTTP for integration with the web while meeting
            specialized requirements such as multicast support, very low
            overhead and simplicity for constrained environments.</t>
          </abstract>
        </front>

        <seriesInfo name="Internet-Draft" value="draft-ietf-core-coap-08" />

        <format target="http://www.ietf.org/internet-drafts/draft-ietf-core-coap-08.txt"
                type="TXT" />
      </reference>
    </references>
  </back>
</rfc>
