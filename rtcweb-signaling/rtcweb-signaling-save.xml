

     <!--  FLUFFY  -->
     
     <t>In building web systems it is often useful for a request to contain
      some state that is passed back in future messages. This system includes
      two types of state, session state, and request state. If a browser
      receives a message that contains state in an setSessionState attribute,
      any future messages it sends that have the same callerSessionId MUST
      include this state in a sessionState attribute. Similarly if a request
      contains an setResponseState attribute, that state MUST be included in
      any response to that request in a responseState attribute. </t>-->


    <!-- FLUFFY -->

      
      <t>At the point that one side which to end the session, it simply sends
      a SHUTDOWN message which is responded to with an OK response. A SHUTDOWN
      can be sent regardless of it any response has been received to the
      initial OFFER.</t>

      <t>There is one addition request called CAP_REQUEST that is used to find
      out the type of capabilities that a browser may support. The browser
      responds to this request with a CAPABILITIES responses that includes SDP
      representing its capabilities.</t>



   <!-- FLUFFY -->

        <!-- 
        <section title="Session Tokens">
          <t>While session IDs serve to uniquely identify a session, it may be
          useful to allow one or another sides to offload state onto the other
          side (for instance to enable a stateless gateway). The
          "setSessionToken" and "sessionToken" fields are used for this
          purpose. When an implementation receives a message with a
          "setSessionToken" field, it MUST associate the field value with the
          session. For all future messages in the session MUST send the
          associated value in the "sessionToken" field (unless the session
          token is reset by another "setSessionToken" value). If no session
          token has yet been received, the "sessionToken" field MUST be
          omitted.</t>
        </section>

        <section title="Response Tokens">
          <t>In addition to tokens which persist for the life of a session, it
          is also possible to have tokens which are only valid for the
          lifetime of a given request/response pair. The "setResponseToken"
          and "responseToken" fields are used for this purpose.</t>

          <t>When an implementation responds to a message from the other side
          (e.g., supplies an answer to an offer, or replies to an answer with
          an OK), it MUST copy into the "responseToken" field any value found
          in a "setResponseToken" field in the message being responded to. If
          no "setResponseToken" field is present, then the "responseToken"
          field MUST be omitted.</t>
        </section>
-->



       <!--
note right of CalleeUA: User alerted

CalleeUA->CalleeJS: sendSignalingChannel();
CalleeJS->CallerJS: {"type":"TENTATIVE_ANSWER", "sdp":"..."}
note right of CallerJS: This SDP has ICE candidates
CallerUA->CalleeUA: More ICE checking
CallerJS->CallerUA: peer->processSignalingMessage();
CallerUA->CallerJS: onstatechange();
note left of CallerUA: Might have media flowing at this point
-->


            <!--
            <t>The callee sends a TENTATIVE_ANSWER message to indicate that the OFFER
            has been received and provide initial media parameters
            (most-likely for one-way media) and ICE candidates.</t>
-->


        <!--
        <section anchor="sec.TENTATIVE_ANSWER" title="TENTATIVE_ANSWER">
          <t>The TENTATIVE_ANSWER is an optional message is used to
          acknowledge that the OFFER has been received and indicate the
          receiver is ready to start ICE negotiation and possible exchange
          media but is not yet ready to commit to which codecs and other media
          parameters will be used. The receiver is keeping open the
          possibility of in the future sending an ANSWER which commits to a
          given set of media parameters for that offer / answer exchange. Note
          that a tentative answer does not necessarily imply that a complete
          answer will be sent because the browser may ultimately decide not to
          answer. However, as with SIP tentative answer allows for
          connectivity establishment, security negotiation, and one-way media
          from the callee to the caller prior to the ANSWER answer <xref
          target="sec.ANSWER"></xref>.</t>

          <t>If the browser subsequently decides to continue the media
          session, it will then send a ANSWER <xref
          target="sec.ANSWER"></xref> message. Note that the ANSWER message
          MAY have different media parameters than the TENTATIVE_ANSWER.</t>

          <t>The TENTATIVE_ANSWER message MUST contain the callee's
          calleeSessionId for this call and an sdp parameter containing ICE
          candidates and provisional media parameters.</t>

          <t><list style="hanging">
              <t hangText="Design Note:">If there was no need to interoperate
              with the SIP Offer/Answer model, we could consider alternative
              designs that add the callee send an ANSWER instead of a
              TENTATIVE_ANSWER then later the callee would send a new OFFER
              instead of an ANSWER when the callee was ready to commit to a
              given set of media codecs. However, SIP Offer/Answer does not
              work that way and using that design here would require the
              signalling GW that received a SIP Tentative Answer, to use that
              as an answer. Later when the signalling gateway received an
              answer form the SIP side, the signalling gateway would have to
              create an OFFER and deal with whatever answer got sent to that
              OFFER. This is close to impossible for the signalling gateway to
              do unless the signaling gateway can anchor the ports and control
              both sides of session in classic B2BUA style. Given the desire
              to build a signaling gateway that does not have to relay media,
              we do not see any way to make a signalling gateway that supports
              only offer/answer on the web side while supporting
              offer/tentative offer/anwer on the SIP side. The proposal in
              this draft is to reuse the SDP Offer / Answer model from SIP and
              that involves both answer and tentative answers.</t>
            </list></t>
        </section>
-->

      <!-- FLUFFY -->

      <!--
      <section title="Notification of Media Termination">
        <t>The SHUTDOWN message is used to indicate the termination of an
        existing session. Either side may initiate a SHUTDOWN at any time
        during the session, including while the initial OFFER is outstanding
        (i.e., before an ANSWER has been sent/received.)</t>

        <t>[FIGURE: SHUTDOWN/OK]</t>

        <figure>
            <artwork alt="Go Read the TXT version of this draft"
                     src="rtcweb-signaling/shutdown.png"><![CDATA[
participant CallerUA
participant CallerJS
participant CalleeJS
participant CalleeUA

CallerJS->CallerUA: peer->close();
CallerUA->CallerJS: sendSignalingChannel();
CallerJS->CalleeJS: { "type":"SHUTDOWN" }
CalleeJS->CalleeUA: peer->processSignalingMessage();
CalleeUA->CalleeJS: onclose();

CalleeUA->CalleeJS: sendSignalingChannel();
CalleeJS->CallerJS: {"type":"OK"}
CallerJS->CallerUA: peer->processSignalingMessage();
CallerUA->CallerJS: onclose();
            ]]></artwork>
          </figure>

        <t>Upon receipt of a SHUTDOWN which corresponds to an existing
        session, an agent MUST immediately terminate the session and send an
        OK message. Subsequent messages directed to this session MUST result
        in an Error: noMatch message. Similarly, on receipt of the OK, the
        agent which sent the SHUTDOWN MUST terminate the session and SHOULD
        respond to future messages with Error: noMatch.</t>
      </section>
-->

      <!-- FLUFFY -->

      <!-- 
      <section title="Capability Discovery">
        <t>It is common for an agent to wish to discover an agent's
        capabilities before starting a media sessions (for instance, to be
        able to display a different icon if video is available.) The
        CAP_REQUEST/CAPABILITIES message sequence is provided for this
        purpose.</t>

        <t>A CAP_REQUEST message is simply an empty message of type
        CAP_REQUEST, e.g., {"messageType":"CAP_REQUEST"}. Because it does not
        create a session, it MUST NOT contain either callerSessionId or cSeq
        values. However, it MAY contain a setResponseToken value attribute to
        allow for response correlation.</t>

        <t>Responding to a CAP_REQUEST message is OPTIONAL. However, an agent
        which opts to do so SHOULD respond with a CAPABILITIES message with an
        "sdp" attribute containing a "sample" offer. This offer SHOULD contain
        an SDP value (minus the ICE parameters) which is representative of the
        type of offer that the agent would make if negotiating a media
        session. For instance, if the agent has a camera and microphone, the
        "sdp" field would likely contain m-lines for both audio and video. An
        agent MAY also respond to a CAP_REQUEST with an Error such as Error:
        failed to indicate that it refuses to respond.</t>

        <t>The following figure shows an example where the web server wishes
        to discover the capabilities of the browser. [FIGURE:
        CAP_REQUEST/CAPABILITIES]</t>

        <figure>
            <artwork alt="Go Read the TXT version of this draft"
                     src="rtcweb-signaling/cap.png"><![CDATA[
participant WebServer
participant CalleeJS
participant CalleeUA

WebServer->CalleeJS: { "type":"CAP_REQUEST" }
CalleeJS->CalleeUA: peer->processSignalingMessage();

CalleeUA->CalleeJS: sendSignalingChannel();
CalleeJS->WebServer: {"type":"CAPABILITIES", "sdp":"..." }
            ]]></artwork>
          </figure>
      </section>
-->


    <!-- FLUFFY -->

    <!-- 
    <section title="Apendix A: Mapping to SIP">
      <t>This section is a non normative suggestions one possible way to build
      a signalling gateway that mapped between SIP and protocol defined in
      this draft.</t>

      <t>The design requires the gateway to be SIP transaction statefull but
      does not require any storage of longer term state. The information that
      remains constant over the SIP dialog is stored in session tokens while
      the information that is needed to from a SIP response is stored in
      response tokens. The gateway appears as a SIP UA to the sip side.
      Message on the two sides of the signalling gateway are referred to as
      the SIP side and web side.</t>

      <t>The following message flows shows an example where the callee is on
      the web side and uses a signaling gateway to reach the callee on the SIP
      side.</t>

      <figure>
        <artwork alt="Go Read the TXT version of this draft"
                 src="rtcweb-signaling/w2p.png"><![CDATA[
participant CallerUA
participant CallerJS
participant SIPGW
participant CalleeUA

CallerJS->CallerUA: peer=new PeerConnection();

CallerJS->CallerUA: peer->addStream();
CallerUA->CallerJS: sendSignalingChannel();
CallerJS->SIPGW: {"type":"OFFER", "sdp":"..."}
SIPGW->CalleeUA: SIP INVITE
note right of CalleeUA: Alert user

CalleeUA->CallerUA: ICE Checking

CalleeUA->SIPGW: SIP 180 w/SDP
SIPGW->CallerJS: {"type":"TENTATIVE_ANSWER", "sdp":"..."}
note right of CallerJS: This SDP has ICE candidates
CallerJS->CallerUA: peer->processSignalingMessage();
CallerUA->CallerJS: onstatechange();
note left of CallerUA: Might have one way\nmedia flowing at this point

CallerUA->CalleeUA: More ICE checking
CalleeUA->CallerUA: ICE Completes
CallerUA->CallerJS: onopen();

CalleeUA->SIPGW: SIP 200
SIPGW->CallerJS: {"type":"ANSWER", "sdp":"..."}
CallerJS->CallerUA: peer->processSignalingMessage();
CallerUA->CallerJS: onopen();

CalleeUA->CallerUA: Two-way Media     
note right of CalleeUA: Media plays

CallerUA->CallerJS: sendSignalingChannel();
CallerJS->SIPGW: {"type":"OK" }
SIPGW->CalleeUA: SIP ACK


note right of CalleeUA: Callee decides to add video

CalleeUA->SIPGW: SIP ReINVITE
SIPGW->CallerJS: {"type":"OFFER", "sdp":"..."}
CallerJS->CallerUA: peer->processSignalingMessage();

CallerUA->CallerJS: sendSignalingChannel();
CallerJS->SIPGW: {"type":"ANSWER", "sdp":"..."}
SIPGW->CalleeUA: SIP 200

CalleeUA->SIPGW: SIP ACK
SIPGW->CallerJS: {"type":"OK" }
CallerJS->CallerUA: peer->processSignalingMessage();
CallerUA->CallerJS: onaddstream();


note left of CallerUA: Caller decides to end the session 

CallerJS->CallerUA: peer->close();
CallerUA->CallerJS: sendSignalingChannel();
CallerJS->SIPGW: {"type":"SHUTDOWN"}
SIPGW->CalleeUA: SIP BYE
CalleeUA->SIPGW: SIP 200
SIPGW->CallerJS: {"type":"OK"}
CallerJS->CallerUA: peer->processSignalingMessage();

            ]]></artwork>
      </figure>

      <section title="Handling SIP Requests">
        <t>When the signalling gateway receives a SIP request, the gateway
        forms the message on the web request side in the following way: <list
            style="numbers">
            <t>The SIP methods INVITE, ACK, BYE, CANCEL are mapped to
            messageType OFFER, OK, SHUTDOWN, SHUTDOWN respectively</t>

            <t>The Seq on web side is formed from the numeric portion of CSeq
            header field value from the SIP side.</t>

            <t>The callerSessionId is formed by a JSON object string that has
            an call-id attribute containing the SIP call-id header field value
            and a from-tag attribute containing the SIP from-tag.</t>

            <t>If there is a SIP to-tag, it is used for the
            calleeSessionId.</t>

            <t>If there is a SIP body containing SDP, it is copied into the
            SDP parameter on web side.</t>

            <t>The setSessionToken is formed by a JSON object string that has
            and contact attribute that contains the SIP contact header field
            value and an route attribute which is an array that has the values
            of the SIP route header field values in reverse order.</t>

            <t>The setResponseToken formed by a JSON object string that has
            and via attribute that is an array containing the SIP via headers
            field values. The JSON object also includes an attribute that
            holds the request method. The gateway MAY include any other SIP
            headers in an attribute named headers which is an array with one
            header field in each entry.</t>
          </list></t>
      </section>

      <section title="Handling SIP Responses">
        <t>When the signalling gateway receives a SIP response, the gateway
        forms the message on the web request side in the following way: <list
            style="numbers">
            <t>The SIP responses 180 is mapped to TENTATIVE_ANSWER. A 200
            response that contains SDP is mapped to ANSWER. 481 is mapped to
            NOMATCH. 408 is mapped to TIMEOUT. 486 is mapped to REFUSED. 491
            is mapped to CONFLICT. All other SIP 3xx to 6xx responses are
            mapped to FAILED.</t>

            <t>The Seq on web side is formed from the numeric portion of CSeq
            header field value from the SIP side.</t>

            <t>The callerSessionId is formed by a JSON object string that has
            an call-id attribute containing the SIP call-id header field value
            and a from-tag attribute containing the SIP from-tag.</t>

            <t>The SIP to-tag is used for the calleeSessionId.</t>

            <t>If there is a SIP body containing SDP, it is copied into the
            SDP parameter on web side.</t>

            <t>The setSessionToken is formed by a JSON object string that has
            and contact attribute that contains the SIP contact header field
            value and an route attribute which is an array that has the values
            of the SIP route header field values.</t>

            <t>The setResponseToken formed by a JSON object string that has
            and via attribute that is an array containing the SIP via headers
            field values. The gateway MAY include any other SIP headers in an
            attribute named headers which is an array with one header field in
            each entry.</t>
          </list></t>
      </section>

      <section title="Handling Web Messages">
        <t>When the signalling gateway receives a WEB message, the gateway
        forms the message on the SIP side in the following way: <list
            style="numbers">
            <t>The messageType OFFER, TENTATIVE_ANSWER, ANSWER, OK, NOMATCH,
            TIMEOUT, REFUSED, CONFLICT, FAILED are mapped to INVITE, 180, 200,
            ACK, 481, 408, 486, 491, 500 respectively.</t>

            <t>The messageType SHUTDOWN is mapped to a CANCEL if the
            calleeSessionId is empty and to BYE otherwise</t>

            <t>For SIP responses, The numeric portion of the CSeq is formed by
            taking the number portion from the Seq field. If the
            setResponseToken contains a method name, that is used for the
            method portion of the CSeq otherwise if it does not exist, the
            request method of the SIP message is used.</t>

            <t>The Call-ID header field values is formed from the call-id
            attribute of the callerSessionId.</t>

            <t>The from-tag is formed from the from-tag attribute of the
            callerSessionId.</t>

            <t>If there is a calleeSessionId, it is used for the SIP
            to-tag.</t>

            <t>If there is a SDP parameter, it is used as a SIP SDP body and
            the content type of and content length headers are set
            appropriately.</t>

            <t>If there is a sessionToken that contains a contact attribute,
            it is used to form the SIP contact header field value.</t>

            <t>If there is a sessionToken that contains a route array, it is
            used to form the SIP route header field values.</t>

            <t>If there is a responseToken that contains a via array, it is
            used to form the SIP via header field values.</t>
          </list></t>
      </section>

      <section title="Limitations">
        <t>The following things, if used on the SIP side, will not
        interoperate:</t>

        <t><list style="symbols">
            <t>Forking</t>

            <t>Redirection via 3xx</t>

            <t>UPDATE / PRACK</t>

            <t>REFER</t>

            <t>SIP to pre RFC 3261 devices that don't support to and from
            tags.</t>

            <t>SUB/NOTify</t>

            <t>OFFERS that do not use early offer</t>

            <t>SIP extensions to RFC 3261.</t>
          </list></t>
      </section>
    </section>
-->
