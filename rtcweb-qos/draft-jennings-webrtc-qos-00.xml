Name: draft-jennings-rtcweb-qos


Title: DSCP and other packet markings for RTCWeb QoS 


Authors: Subha Dhesikan, Dan Druta?, Cullen Jennings, James? Paul?
Abstract[a]:


Many networks, such as Service Provider and Enterprise networks, can prioritize packets based on various Differentiated Services Code Points (DSCP). This document defines the recommended DSCP values for browsers to use for various classes of traffic. 


This draft is a very early and far from done. It is meant to provide the structure for the idea of how to do this but much discussion is needed about the details. 
Introduction:


DiffServ style packet marking can help provide QoS in some environments. There are many use cases where they do not help but they seldom make things worse. This draft proposes how browser and other VoIP applications can mark packets. This draft does not contradict or redefine any advice from previous IETF RFC but simply provides a simple set of recommendations for implementors based on the previous RFCs. 


There are some environments where priority markings frequently help. These include:


1. If the congested link is the broadband uplink in a Cable or DSL scenario, often residential routers/NAT support prioritization based on DSCP.
2. If the congested link is a local WiFi network, marking may help.
3. In some some cellular style deployments, markings may help in cases where the network does not remove them. 


Traditionally DSCP values have been thought of as being site specific, with each site selecting its own code points for each QoS level. However in the RTCWeb use cases, the browsers need to set them to something when there is no site specific information. This document describes a reasonable default set of DSCP code point values drawn from existing RFCs and common usage. These code points are solely defaults. Future drafts may define mechanisms for 
site specific mappings to override the values provided in this draft.  


This draft defines some inputs that the browser can look at to determine how to set the various packet markings and defines the a mapping from abstract QoS policies (media type, priority level) to those packet markings.


Terminology
TODO add the boiler plate
Inputs
The first input is the type of the media. The browser provides this input as it knows if the media is audio, video, or data. In this specification, audio and video media always refers to interactive media where low latency is desired - streaming media[b] is out of scope.[c] 


The second input is the relative priority of the stream within that session.  Many applications have multiple video streams and often some are more important than others. 
Javascript applications can tell the browser whether a particular media stream is high, medium, or low importance to the application.


DSCP Mappings:
Importance             Low                   Med                   High
Video                      38 (AF43)             36 (AF42)           34 (AF41) 
Audio                      46 (EF)             46 (EF)             46 (EF) 
Data                       8 (CS1)                   0 (BE)             10 (AF11)
QCI Mapping:
Importance  Low         Med         High
Video                  2         2         2
Audio                  1         1         1
Data            9         9         3 


This corresponds to the mapping provided in TODO REF which are:
QCI values (LTE)


1   GBR       2  Interactive Voice
2   GBR       4  Interactive Video
3   GBR       5  Non-Interactive Video
4   GBR       3  Real Time Gaming 
5   Non-BGR   1  IMS Signalling
6   Non-BGR   7  interactive Voice, video, games
7-9 Non-BGR   6  non interactive video / TCP web, email, / Platinum vs gold user ?


WiFI Mapping:
Importance
	Low
	Medium
	High
	Video
	5
	5
	5
	Audio
	6
	6
	6
	Data
	1
	0
	3
	

This corresponds to the mappings from TODO REF of 


Priority        802.1p Priority 802.1p Designation        Traffic Type        Access Category (AC)        Designation
Low        1        BK                Background        AC_BK        Background
            2        -        (spare)                AC_BK        Background
            0        BE        Best Effort        AC_BE        Best Effort
           3        EE        Excellent Effor AC_BE        Best Effort
           4        CL        Controlled Load        AC_VI        Video
           5        VI        Video                AC_VI        Video
           6        VO        Voice                AC_VO        Voice
High        7        NC                Network Control        AC_VO        Voice




W3C API Implications
To work with this proposal, the W3C specification would need to provide a way to specify the importance of media and data streams. 


The W3C API should also provide a way for the application to find out the source and destination IP and ports of any flow as well as the DSCP value or other markings in use for that flow. The application can then communicate this to a web service that may install a particular policy for that flow. 


TODO: "Access Agnostic Quality of Service" - consider possibility of using process like ALTO Discovery process (reverse lookup IP to get domain, then NAPTR on domain) to find a QoS server that is informed about about the flow.  




Security Considerations


TODO - discuss implications of what browser can set and what JS can set 


IANA Considerations


This specification does not require any actions from IANA. 


Acknowledgements
Thanks for hints on code to do this from Paolo Severini, Jim Hasselbrook, Joe Marcus, and Erik Nordmark <nordmark@cisco.com>.






References
RFC 4594
RFC 3246
RFC 2474
RFC 2597


Appendix: Code Hints  
On windows setting the source interface works but BSD, OSX, Linux use weak end-system model and will route out different interface if that looks like a better route. (TODO - Can someone verify this with specific versions)  [d]


In windows you might be able to tell something about priority of an interface for ICE purposes with WlanQueryInterface or GetIfTable. 


The specific mechanisms required to set DSCP code points depend on the application platform.


In windows, setting the DSCP is not easy. See Knowledge Base Article KB248611. TODO - add more information about what can be done for windows. 


For most unix variants, the following program can set DSCP. 


TODO - make this work in V6. For v6 have a look at IPv6_TCLASS or better the tclass part of sin6_flowid for IPv6


TODO - Can someone test and report back results of program in iOS, Android, Linux, OSX, BSD. 


Example test program:




#include <sys/types.h>
#include <sys/socket.h>
#include <netdb.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <errno.h>
#include <unistd.h>


#define MSG "Hello, World!"


int
main(void) {
        int sock = -1;
        struct sockaddr *local_addr = NULL;
        struct sockaddr_in sockin, host;
        int tos = 0x60; /* CS3 */
        socklen_t socksiz = 0;
        char *buffer = NULL;


        sock = socket(AF_INET, SOCK_DGRAM, 0);
        if (sock < 0) {
                fprintf(stderr,"Error: %s\n", strerror(errno));[e]
                exit(-1);
        }


        memset(&sockin, 0, sizeof(sockin));
        sockin.sin_family = PF_INET;
        sockin.sin_addr.s_addr = inet_addr("11.1.1.1");
        socksiz = sizeof(sockin);


        local_addr = (struct sockaddr *) &sockin;


        /* Set ToS/DSCP */
        if (setsockopt(sock, IPPROTO_IP, IP_TOS,  &tos,[f]
            sizeof(tos)) < 0) {
                fprintf(stderr,"Error setting TOS: %s\n", strerror(errno));
        }


        /* Bind to a specific local address */
        if (bind(sock, local_addr, socksiz) < 0) {
                fprintf(stderr,"Error binding to socket: %s\n", strerror(errno));
                close(sock); sock=-1;
                exit(-1);
        }


        buffer = (char *) malloc(strlen(MSG) + 1);[g]
        if ( buffer == NULL ) {
                fprintf(stderr,"Error allocating memory: %s\n", strerror(errno));[h]
                close( sock ); sock=-1;
                exit(-1);
}
        strlcpy(buffer, MSG, strlen(MSG) + 1);
        memset(&host, 0, sizeof(host));
        host.sin_family = PF_INET;
        host.sin_addr.s_addr = inet_addr("10.1.1.1");
        host.sin_port = htons(12345);


        if (sendto(sock, buffer, strlen(buffer), 0,
             (struct sockaddr *) &host, sizeof(host)) < 0) {
                fprintf(stderr,"Error sending message: %s\n", strerror(errno));[h]
                close(sock); sock=-1;
free(buffer); buffer=NULL;
                exit(-1);
        }


        free(buffer); buffer=NULL;
        close(sock); sock=-1;


        return 0;
}




[a]Cullen Jennings:
Feel free to rewrite anything I have put in.
[b]Subha D:
Cullen, why did you decide to make steraming media out of scope? This is an important type of traffic served by the browser toda. Example: training video, company broadcast, digital media etc. Just trying to understand.
[d]ekr:
Why is this relevant here?
[e]ekr:
fprintf(stderr,...)
[f]ekr:
why are you casting this? setsockopt's third argument is a void *. In C any argument can be automatically converted to (void *)
[g]ekr:
Maybe check the return value? Otherwise, you could just call strdup. For that matter, why are you copying message, just send it directly.
[h]ekr:
fprintf(stderr,..)